library IEEE;
library WORK;

use IEEE.STD_LOGIC_1164.all;

use WORK.CPU_LIB.all;

entity ID_PHASE is
	port(
		-- controll
		clk: STD_LOGIC;
        reset: STD_LOGIC;

        -- if phase
        new_pc : REG_TYPE;
        instruction : REG_TYPE;

        -- ex phase
		instruction_type : out INSTRUCTION_TYPE_TYPE;

		opcode: out OPCODE_TYPE;
		cond: out COND_TYPE;

		is_signed: out STD_LOGIC;
		load_store: out STD_LOGIC;
		
		shift_operation: out STD_LOGIC;
		shift_type: out SHIFT_TYPE_TYPE;
		
		immidiate: out REG_TYPE;

		Rn		: out REG_TYPE;
		Rs		: out REG_TYPE;
		Rm		: out REG_TYPE;
		
		RdAddr : inout REG_ADDR_TYPE;

		-- if and ex phase
		pc : out REG_TYPE;
	);
end entity ID_PHASE;

architecture STR of ID_PHASE is

	component INSTRUCTION_DECODER is
		port
		(
			-- Input ports
			instruction	: in REG_TYPE;

			-- Output ports
			instruction_type : out INSTRUCTION_TYPE_TYPE;
			opcode: out OPCODE_TYPE;
			cond: out COND_TYPE;
			
			is_signed: out STD_LOGIC;
			load_store: out STD_LOGIC;
			link_flag: out STD_LOGIC;
			
			RnAddr: out REG_ADDR_TYPE;
			RdAddr: out REG_ADDR_TYPE;
			RmAddr: out REG_ADDR_TYPE;
			RsAddr: out REG_ADDR_TYPE;
			
			shift_operation: out STD_LOGIC;
			shift_type: out SHIFT_TYPE_TYPE;
			
			immidiate: out IMMIDIATE_TYPE
		);
	end component;

	component REGISTERS is
		generic (
			PC_ADDR : NATURAL := 15
		);
		
		port 
		(	
			clk		: STD_LOGIC;
			reset	: STD_LOGIC;

			RnAddr	: REG_ADDR_TYPE;
			RmAddr	: REG_ADDR_TYPE;
			RsAddr	: REG_ADDR_TYPE;

			RdAddr	: REG_ADDR_TYPE;
			Rd 		: REG_TYPE;
			PCin 	: REG_TYPE;
			we		: STD_LOGIC;
			
			Rn		: out REG_TYPE;
			Rs		: out REG_TYPE;
			Rm		: out REG_TYPE;
			PCout	: out REG_TYPE
		);

	end component;

	component SIGN_EXTEND is
		port
		(
			a : in IMMIDIATE_TYPE;
			result : out REG_TYPE
		);
	end component;

	signal RnAddr : REG_ADDR_TYPE;
	signal RmAddr : REG_ADDR_TYPE;
	signal RsAddr : REG_ADDR_TYPE;
		
	signal immidiate_16 : IMMIDIATE_TYPE;
begin
	U_ID: INSTRUCTION_DECODER 	port map (
										instruction => instruction,				--in ID_PHASE.instruction

										RnAddr => RnAddr,						--out REGISTERS.RnAddr
										RmAddr => RmAddr,						--out REGISTERS.RmAddr
										RsAddr => RsAddr,						--out REGISTERS.RsAddr
										RdAddr => RdAddr,						--out REGISTERS.RdAddr, ID_PHASE.RdAddr

										instruction_type => instruction_type, 	--out ID_PHASE.instruction_type
										opcode => opcode,						--out ID_PHASE.opcode
										cond => cond,							--out ID_PHASE.cond
										is_signed => is_signed,					--out ID_PHASE.is_signed
										load_store => load_store,				--out ID_PHASE.load_store

										-- link_flag => link_flag,				--out TODO: Implement PC LinkReg transfer

										shift_operation => shift_operation,		--out ID_PHASE.shift_operation 
										shift_type => shift_type,				--out ID_PHASE.shift_type

										immidiate => immidiate_16				--out SIGN_EXTEND.a
					  				);

	U_R: REGISTERS port map (
							clk => clk, 		--in ID_PHASE.clk 
							reset => reset, 	--in ID_PHASE.reset 

							PCin => new_pc, 	--in ID_PHASE.new_pc 
							Rd => ZERO_32, 		--in TODO: Implement logic for loading Rd register
							we => '1',			--in TODO: Implement logic for turning this on/off
							PCout => pc, 		--out ID_PHASE.pc 

							RnAddr => RnAddr,	--in INSTRUCTION_DECODER.RnAddr
							RmAddr => RmAddr,	--in INSTRUCTION_DECODER.RmAddr
							RsAddr => RsAddr,	--in INSTRUCTION_DECODER.RsAddr
							RdAddr => RdAddr,	--in INSTRUCTION_DECODER.RdAddr

							Rn => Rn,			--out ID_PHASE.Rn
							Rs => Rs,			--out ID_PHASE.Rs
							Rm => Rm			--out ID_PHASE.Rm
						);

	U_SE: SIGN_EXTEND 	port map (
								a => immidiate_16, 	--in INSTRUCTION_DECODER.immidiate
								result => immidiate --out ID_PHASE.immidiate
							);
end architecture STR;

